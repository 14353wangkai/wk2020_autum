## 分布式

- 分布式版本控制新建分支、合并分支操作速度非常快
- 集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制**每个人的电脑上就有一份完整的代码**

## 中心服务器

- 中心服务器用来交换每个用户的修改，**没有中心服务器也能工**作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。
- github就是中心服务器

## 工作流

- 新建一个仓库之后，当前目录就成为了工作区，工作区下有一个**隐藏目录 .git，它属于 Git 的版本库。**

  

  ![img](https://camo.githubusercontent.com/f27f376ff5487a5a21bf093edf616762d4aa6a7d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230303031343339352e706e67)

- 三个区域

  - 工作区：程序员打代码的文件目录
  - 暂存区：工作区内容add之后会放到暂存区，暂存区通过checkout --files可以将文件从暂存区回滚，**覆盖本地对应文件**，之所以叫暂存区，是因为这里面的文件会在提交或者回滚之后就消失。
  - 本地仓库（history，将所有分支存储）：暂存区commit之后跳转到本地仓库，仓库将保留版本信息，通过 git reset 利用将文件从history仓库中取回
  - 远程仓库：git push origin originName,  这里origin是一个仓库名变量，originName则是具体仓库名称

## 分支原理

- 每个分支都有一个头部指针

- head指针：二级引用，意在指向分支的最新版本

  - 默认是指向最新一次commit的分支的头部指针，如下图所示，dev分支提交了一个最新的版本

  - <img src="/Users/wangkai/Library/Application Support/typora-user-images/image-20200711152627445.png" alt="image-20200711152627445" style="zoom:33%;" />

    

- 合并分支：[https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6](https://git-scm.com/book/zh/v2/Git-分支-分支的新建与合并)

  

  - <img src="https://camo.githubusercontent.com/474685d7724731a6c34567b50c45efd25b1592e1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333031303534302e706e67" alt="img" style="zoom:33%;" />

- 快速合并：fast forward

  - 如果需要合并的分支的头部指针，是当前分支头部指针的后继节点，那么合并的时候，不会存在冲突，因此只是将当前指针向后移动一位，不会做额外的操作，这被称为fast forward，而fast forward之后，被合并分支可以被删除，因为它已经和master分支已经是同一个链路了
  - 无疑，这会导致这个被合并分支没有历史信息，即我们无法回退到还没有合并的那个版本（不知道有什么坏处）

- 非快速合并

  - 假设当前处于这个状态，想要合并iss53到master，此时iss53并非master的后续节点

  - ![一次典型合并中所用到的三个快照。](https://git-scm.com/book/en/v2/images/basic-merging-1.png)

  - 想要合并，就必须先找到公共的祖先节点，就是上图的c2，然后以C2作为公共部分，合并c4和c5中的内容，创建节点c6，将master的head指针指向此处

    

  - ![一个合并提交。](https://git-scm.com/book/en/v2/images/basic-merging-2.png)

    

- 合并冲突：当两个分支都对同一个版本的同一文件的同一个部分进行了修改，那么git将无法直接合并

  - 当出现冲突的时候，使用git status就能看到有一个unmerged状态， 在这个状态下列出的文件一般是有冲突的。
  - Git 会将两个都写进去，然后使用 <<<<<<< 标志head所处文件的内容，======= 表示分割线 ，>>>>>>> 表示合入分支的文件内容，在这里就是iss53，从而标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突 （但这个过程不能自动进行，因为git无法判断哪个逻辑才是合理的，因此冲突只能通过两个分支的程序员协商之后进行统一）



## 为什么叫做pull request

- 对仓库进行了贡献之后，指定code reviewer进行检查，意思就是“我想要合入你的仓库，请你（request）将我的代码拉取（pull）下来”