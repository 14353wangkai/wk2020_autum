## MySQL和MyBatis

### mysql特点

- 关系型数据库
- 一致性
  - mvcc
  - 事物（acid）
  - b+tree 索引：支持范围索引
  - 自适应哈希缓存
- 从库和主库是有时间差的
  - 在业务要求主从数据库完全一致的时候，要设计屏障逻辑
- 文档，图片，音频视频等不适合存储在数据库中，适合存储在云盘中

### 结构化与非结构化存储

- 结构化存储：读多写少，对数据一致性要求高
- key-value存储：配合结构化数据，如缓存，分布式
- elasticSearch：倒排索引查询文档（索引的反义词，倒排索引就是通过文档内的单词为索引，单词所在文档为value），复杂条件查场景
- hbase：列存储，key查询，水平扩容，im消息



### 最佳实践

- mysql读写分离
  - 采用主从结构，读qps可以水平扩容
  - 单表数据体量过大的时候需要进行分表甚至分库
- mysql+redis
  - 热点数据
- mysql+es
  - 将mysql的一些数据同步到es中，在复杂条件查询的时候调用es

### 表设计

- 一致性
- 不要用TEXT，BLOB类型，避免不了责需要拆表
- 大字段和冷门数据需要进行分表
- 字段越小越好，避免null列，提高索引效率





### 索引规范

- 避免使用临时表
- 有利于分组和排序+范围索引 



## 建立索引原则

- 索引列区分度高，不要以性别之类的属性来区分
  - SELECT COUNT(distinct column_name)/count(*) from table_name
- 整体索引占用空间小
- 前缀索引
  - 长类型：TEXT等
  - 前缀区分度高
  - Select count(distinct left(column_name, prefix_lenght)/count(*) from table_name)
- 组合作引：最左匹配原则

- 索引覆盖：查找的数据回生成一个索引，防止回表
- 化繁为简
  - 不建议两张表以上的join
  - 减少锁的竞争
- 事物简单，拒绝大sql，大事物，大批量
  - 拒绝嵌套rpc
  - 大事务
- 不要用 select *，减少io
- 避免触发器，函数，存储过程的使用，由应用代码来完成这些逻辑，降低耦合
- limit高效分页
  - 不建议 limit offset, size
  - 建议 id> offset, limit size, 减少数据查询
- like避免前置%



## expain 

- 慢查询分析工具

- 常用于看select，参数

  - select_type：是联合查询，子查询还是普通产讯

  - type：关键的关键字

    - const：通过一次索引能找到
- eq_ref唯一性索引扫描，对于每个索引key，只有一个记录匹配
    - ref：非唯一索引扫描，返回匹配某个关键字的所有行
- range：范围查询，常用于in，>, <, between
    - Index：索引无用
- all：全表扫描

- Partition：用到了联合索引
- passible_key
- Filtered: 查找出来的数据经过server筛选之后剩下多少

- 新版本支持update分析

- 出现的问题

  - 通过order by导致全表查询
  - 大事务导致的case
    - 事务嵌套耗时网络请求导致数据库更改操作超时
  - 主从延迟导致
    - 对延迟敏感的业务



## 一条更新语句执行顺序

### 比如：update T set c=c+1 where ID=2;

- 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
- 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
- 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
- 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

这个update语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。



## 数据库

- 主键选举规则
  
  - 数据库的三范式
    - 1NF：原子性，列不能再分
    - 2NF：满足1NF，一个表一定会有一个主键，其他列只能由主键中所有的列唯一决定，不能存在某一列部分依赖于主键
    - 3NF：满足2NF，并且不存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
  
- 反范式设计
  
  - **主键应当是对用户没有意义的**。业务上的‘主键’可以通过唯一键（Unique Key）或唯一索引（Unique Index）和其它约束条件实z现
  - 主键最好是单列的
  - 因为主键是没有意义的，所以最好不要去更新主键
  - 主键不能包含动态变化的数据，比如时间戳不能作为主键
  - 反范式设计允许出现冗余列，防止过多的join
  
- 分表
  
  - 分表策略
    - 水平分：仍然保持数据表结构，但是将一部分数据放入到另一个表中。
    - 垂直分：将某些属性抽取出来，形成新的表，一般是冷热分离，当冷数据多的时候
  
- 垂直分库分表产生的问题：

  - 分表：跨表查询，需要用join
  - 分库：跨库查询，无法使用同一个sql语句实现，只能通过两条语句查询出来之后，再在程序中进行合并

- 水平分库分表产生的问题

  - 分库：会产生大量实例，导致很大的问题
  - 分表：配合分库，减少数据库实例

- 删除1亿数据量的数据表中的5千万条数据
  
- 首先将剩余的五千万条数据找出来，插入到新的表中
  - 然后利用truncate命令删除整张表
  
- 读写分离
  - 有主数据库和从数据库
  - 写(update, insert, delete)请求是访问主数据库，读请求是访问从数据库
  - 从数据库会有操作日志，在主数据库完成操作的一段时间之后，从数据库才会进行更新
  
- 事务
  - ACID：原子（undo日志：出错回滚，临界区只有一个线程），一致（操作前后保持逻辑一致），隔离（保证多事务并行的结果和串行的结果是一样的），持续（redo 日志）

  - 如何保证事务持久性
    - redo log：一些事物提交之后，为了保障事务的**持久性**和**一致性**，防止在数据库中写到一半宕机，innodb选择先不将修改的数据写入磁盘，而是将redo log写入buffer，在buffer中再往硬盘中写入，
    - undo log：给事务一致性提供保障的日志
    
  - 为什么要有事务
    
    - 保持数据操作的原子性，数据前后的一致性，数据操作的隔离性
    
  - CAP原理

    - 一致性，可用性，分区容错性，只能三选二
    - 分区容错基本是必要的，因此一般是二选一，对于银行，商城这样的，是宁愿可用性低，也要保留一致性，对于实时性高的应用场景（想不起来），可用性（只要保障每次请求都会有返回，但是并不需要保障是最新的数据）又是必要的，一致性到可以忽略

  - BASE原理

    - 基本可用性：熔断降级，在出现故障的时候，容许一些非核心功能缺失，尽量保全核心功能
  - 软状态：允许**部分节点的数据存在一定延时**，但是不能影响可用性。
    - 最终一致性：在软状态之后，数据要保持一致
  - 通过让系统放松对面某一个时刻的数据一致性的要求来换取系统整体伸缩性和性能的改观。
    
  - 分布式事务

    - 2pc和3pc的优劣

      - 2pc：事务，事务提交
      - 3pc：

    - TCC:

      - 三个状态: try confirm cancel
      - try的时候，询问每个节点，是否出故障
      - 如果没有出故障，默认每个节点都是有能力提交事务的，于是进行confirm，如果confirm失败，那么对应的节点重新confirm或者人工介入
      - cancel同理，如果有一个节点在try的时候失效，那么其他已经确认的节点都要进入cancel阶段

    - paxos和raft

      - paxos问题指分布式系统中存在故障，但不存在恶意污染节点的场景，也就是消息会丢失，但是不会造假下达成共识的场景
      - paxos基于两阶段提交事务，算法中，节点分为三个类型
        - 倡议者 proposer：提交一个提案，往往是客户端担任
        - 接收者 acceptor：负责对提案进行投票，由服务器担任。提意只要超过半数的接收者投了票，就可以被选中
        - 学习者 learner：被告知提案结果，并与之统一卖不参与投票过程。客户端和服务端都可以作为学习者。
      - prepare阶段：
        - 当Acceptor收到一个prepare请求，包含的提意是[n1, v1]，并且之前还没有接受过prepare请求，那么发送一个preare响应，设置接收到的提意未[n1,v1] 以后都不会接受小于n1的提意
        - 如果接收到的提意比当前版本号大，那么发送prepare响应，这个响应包含之前的提意，设置当前接收到的提意，

      

  - 四大隔离等级：读未提交，读已提交，重复读（mvcc，数据后面接版本号），序列化（加锁）

  - 四大隔离等级是如何实现的？

    - 主要是中间两个等级，RC和RR，首先要知道ReadView的概念

      - 进行查询操作的时候，事务会生成一个readview，这是一个事务快照，是当前时间点，系统内活跃的事务列表，存储了所有当前时间点未提交的事务。
      - 当查询数据的时候，事务会拿readview到undo log中判断。如果查询到某一天数据
        - 首先查看undo log中的最新数据行，如果数据行的版本号小于readview记录的事务id最小值，就说明这个数据对当前数据库是可见的，可以直接作为返回结果给事务
        - 如果数据行版本号大于readview的**最大值**，说明这个书由一个新的事务修改过了，对当前事务是不可见的，此时不能找它作为返回值，要之前版本满足条件的行版本
        - 如果数据行版本号在readview的最小值和最大值之间，那么此时需要遍历整个readview，如果数据版本等于readview的某个值，说明该行数据仍处于未提交状态，无疑对当前事务不可见

    - 读已提交:

      - 也是通过MVCC来实现的，**事务在每次读操作的时候，都会产生一个新的readview，当前最大的readview就是这个事务**
      - 在这个期间如果某个事务提交了，当前事务就会从readview移除，然后创建新的readview，这样就确保每次都能产生新的数据视图

    - 可重复读

      - 事务只有在第一次进行读操作的时候，才会生成一个readview，后续的操作都会重复使用这个readview。

      - 换句话说，即便此时由其他事务提交了数据对于可重复读也是不可见的

        

  - 快照读和当前读

    - 对于需要修改数据库的操作而言，读取数据都是“当前读”
      - **MVCC+next-key locks**：next-key locks由record locks(索引加锁/行锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)的结合，next-key lock 会锁定范围和自身行，比如select...where id<6，锁定的是小于6的行和等于6的行 
    - 对于普通的查询而言，读取数据都是“快照读”，禁止更新类似cas，更新完发现和当前版本号不一致，那么在事务提交之后，该
      - 查询时需要同时满足以下两个条件
        　　1、查找数据版本号，早于（小于等于）当前事务id的数据行。 这样可以确保事务读取的数据是事务之前已经存在的。或者是当前事务插入或修改的。
          　　2、查找**删除大于当前事务版本号的记录**。 这样确保取出来的数据在当前事务开启之前没有被删除。

  - 不同隔离等级导致的读问题：
    - 脏读：发生在读未提交，也就是事务1更改某数据之后尚未提交，事务2就可以对数据进行读取，此时事务1发生错误，进行回滚，又将数据改回去，导致事务2读取到无效数据。
      - 问题场景：银行取钱，A给银行卡X打了100元，B读取发现银行卡多了100，然后出现故障，A事务尚未提交就进行了回滚，那么B实际上没有多钱。
    - 不可重复读：事务操作的时候，对同一个索引的数据读取出不同的结果，出现在事务1对某数据修改完进行提交之后，事务2读取该数据，然后事务1又对数据进行第二次修改，当事务2对该数据再次读取的时候，就会
    - 幻读：快照读可以解决幻读，当前读必须建立间隙锁来锁住对应位置的内容。
    
    
    
  - 注解：@Transactional

  - spring中的事务



- 什么时候会导致索引匹配问题？
  - 最左前缀不满足
  - 使用函数
  - 用or连接
  
- 为什么不建议使用*

  - *是必须回表查询的

  



