## java基础

- hashmap实现
  - 扩容
    - 为什么是2的倍数
    - 如何判断什么时候扩容
  - rehash
  - 扰动函数
  - 是线程安全吗
    - 不是，会出现什么问题
      - 如果采用的是头插法插入数据，多线程扩容的时候可能会形成循环引用
      - 多个线程插入数据的时候，是不能保证有序性的
      - map更新过程不是原子性的， 可能在一个线程删除一个锁
    - 为什么头插法会出现循环引用
      - 因为头插法在扩容的时候，对应slot的链表会被翻转（2->1 ==>. 1->2），在多线程的时候，如果两个线程同时执行扩容操作，那么就可能出现e->next->e这样的环状引用问题（比如B首先得到e, 以及next = e.next, 此时时间片用完，然后A进行扩容，同样取得e, next=e.next，完成头插法之后，会由于反转形成next->e，此时B再进行扩容，一定是先插入e，于是这样就导致e->next->e的奇怪循环。
  - currentHashmap什么原理？
    - 1.7是分段二次哈希，给每一个segement都加一把锁，从而让并发量便为hash.size()/segementNum;
    - 1.8是头节点加锁，cas+volatile
    - 扩容的时候是多线程协助并发扩容，这里非常不理解
- 动态代理
  - 反射：reflect
  - 调用拦截: invokationhandler

## jvm

- 类加载过程

  - 加载：加载字节码到类对象中

  - 连接

    - 验证：检查Class文件中数据的正确性
      - 比如一些版本号
      - 常量池
    - 准备：给静态变量分配存储空间，并分配初始值
    - 解析：将符号引用转换为直接引用,  符号是一个常量，此时对应的方法或者对象可能并没有创建，转换成直接引用的时候，这些符号将会对应为一个个地址？

  - 初始化：什么时候会出发初始化

    - 对象被创建的时候（本对象以及父类对象）

    - 访问静态变量的时候（final静态变量不会触发初始化）

    - 调用静态方法的时候（即便final也会）

    - 反射调用调用类对象方法的时候

      

  - 双亲委派构造：子类被创建的时候，会让迭代地让父加载器加载（这个父类并不是继承关系的父类，而是处于靠近调用根的类加载器，父加载器是可以发现子加载器的内容的，这和继承相反）这样做的好处在于，具有同样名字的类不会被加载多次，更有安全性。

    ![img](https://user-gold-cdn.xitu.io/2019/5/6/16a8d30870f9a8e5?imageslim)

  - 内存问题
  
    - 堆溢出：gc未能正确删除
    - 栈溢出：
  
  - 什么可以作为gc root
  
    - 栈中引用的对象
    - 方法区类静态属性引用的对象
    - 常量引用的对象

## currentHashMap

- 1.8不会reHash，1. 扩容长度是旧的2倍；2. 扩容后要么元素在原位置，要么放置在扩容前的原始位置+扩容的大小值（=旧数组的长度）=新位置；3.  只需要计算key的hash值新增参与运算的位是0还是1，就可以迅速得出了扩容后的储存方式，0=原位置，1=原位置