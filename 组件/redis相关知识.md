## 效率提升原理

- 空间换时间

### 基础数据1: String，SDS

- 将char数组转换为simple dynamic string，杜绝strlen的o(n)复杂度
- 在扩容前会首先判断free是否足够大，如果足够大，那么就分配这么多空间，否则，就重新分配空间之后，再扩展

### 基础数据2: list，quicklist

- 双向链表，支持左右插入和pop
- quicklist，因为是cpp写的，cpp的链表每个节点处于堆中，分布在不连续内存块，quicklist为了增快访问，把链表的一个节点扩展为一个
- quicklist中每一个元素都是ziplist

### 基础数据3：字典

- 扩容
  - 负载因子
    - load_fact = ht[0].used / ht[0].size
  - 条件
    - 服务器没有在执行bgsave或者bgrewriteaof命令的时候 && 负载因子 >= 1
    - 服务器正在执行bgsave或者bgrewriteaof命令的时候 && 负载因子 >= 5
  - 二倍扩容 

### 基础数据4：set

- 和hashset类似

### 基础数据5：zset

- ziplist：
  - 连锁更新和变长编码，目的是为了省去左右节点
  - 本身是有序的，但是性能差，是插入排序
- skiplist
  - 



## redis 缓存一致性

- 一般选择方案：每次更新数据库中条目之后，都将redis中对应的缓存项进行删除，这样可以大大降低数据不一致的情况
- 先更新后删除的操作可能遇到的不一致问题
  - 删除失败：通过确认机制（参考tcp确认重传）确保删除成功
  - 对同一条数据的读取和更新的两个线程竞争
  - 线程B读取数据库，还没有来得及更新缓存
  - 线程A写入更新
- 以下方案存在的一些问题，假设有A线程和B线程竞争同一条数据
  - 先更新数据库后更新缓存
    - A更新数据库之后，尚未更新缓存，进入阻塞
    - B访问统一条数据，发现缓存中有旧值，返回脏数据
  - 先更新缓存后更新数据库
    - 一旦更新数据库失败，因为缓存的持久化机制没有那么强，那么这条数据可能到期就丢失了
    - 一旦更新的数据失效，再读如缓存中的可能就是失效数据了
  - 先删除缓存后更新数据库
    - A删除缓存之后，阻塞
    - B读取相同数据的时候，发现缓存不见，从数据库取了脏数据
    - 更新缓存

## redis 数据恢复

- 哨兵模式（三个监听节点）
- 哨兵节点的主从选举
- 数据以rdb和aof的形式恢复

## redis 分布式锁

- 分布式锁产生原因

  - 曾经利用synchronized关键字可以实现单机情况下多并发的锁
  - 当高并发访问分布式节点的时候，普通的锁就行不通了，因为代码在不同节点中肯定是不属于同一个对象的，此时synchronized给对象加锁的做法就失效了
  - 分布式锁的产生就是为了解决分布在不同节点的相同方法的同步性问题产生的，分布式锁是一种更粗粒度的锁，目的在于给节点加锁。
  - 题外话：zookeeper原本的目的是为了实现分布式锁。

- redis分布式锁

  - 锁的实现关键在于**给各个竞争对象的公共部分加上一个互斥约束**，从而实现并发 -》串行化的转换，就想sychronize其实锁住的是一个公共对象，只要访问的方法用到了这个对象，那么就会有互斥约束。
  - 对于redis来说，key值对于所有节点而言都是唯一的，但又是对所有节点可见的，因此redis可以给key加一把锁，从而让整个持有对应key的集群受到同一个变量的约束
  - 可能会遇到的问题
    - 在set的过程中保持原子性，将expire时间加入到set函数中，防止expire之前进程被中断
    - 其它节点执行了del key怎么办，每次加锁的时候将节点的ip设置为value值，在del之前，先判断一下是不是本机ip

  

## redis持久化

### RDB

- 概念
  
  - 全量备份，快照，会在一段时间内生成指定时间点的数据集，保存在硬盘中
  
- 相关问题
  - 问题一：redis是单线程程序，注意，单线程程序指的是一个进程上有一个线程，而不是说这个程序知识一个线程。如果直接一边处理线上请求，一边处理内存快照存储，会严重拖累服务器响应时间，这个问题如何处理
  - 问题二：redis必然是一个非阻塞模型，这引出了数据同步问题，即在持续话的同时，有一个请求把某个持续化的对象删除了，应该怎么处理。
  
- 原理

  - 写时复制（COW）

  - 子进程处理备份操作

    - redis在持久化的时候，会产生一个子进程，快照持久化是通过这个进程来处理的。
    - 对于COW的子进程来说，刚fork出来的子进程是不会单独运行的，它共享父进程的代码和数据

  - 当父进程对其中一个页面数据进行修改的时候，此时会有写操作，**写时复制**，说的就是父子进程需求有冲突的时候，相关的那段数据才会发生改动

  - 在cow的过程中，父子进程共享的页面将复制一份分离，由父进程对这个复制的页面进行修改，子进程仍然是写入没有修改过的版本，**这同时解决了两个问题**

    - 解决一：虽然多了一个进程做任务多少会导致父进程的cpu占用率变低，但是父进程不会收到io瓶颈的影响，因此可以接受。
    - 解决二：子进程无需感知数据变化，只要持续持续对启动时的数据进行序列化即可，因此数据不会因为外部的操作而丢失

  - 适合读密集的请求，不适合写密集的请求，否则写时复制将会导致大量的复制操作。

    

### AOF日志

- 概念

  - 增量型备份，要定期执行从而进行日志“瘦身”，否则将会带来无可挽回的问题

- 原理

  - 子进程并非把数据快照持久化，而是将操作写入日志进行持久化，与其他操作日志不同的地方在于，Redis的AOF是操作指令执行完毕之后子进程才会写入操作日志。

  - 子进程在写操作的时候，为了跟上操作速度，首先会将内容写入到内存缓存中，然后子进程再进行异步持续化。

  - 宕机备份：如果子进程还没将操作写入其中就发生了宕机，那么将会导致AOF数据丢失

    - 这并没有什么特别好的方法，只能让内存中未能写入磁盘的数据不要越积累越多，导致一次损失过大
    - fsync( force synchronize) 函数提供了一个强制同步的接口，调用了这个就强制将所有数据都写入磁盘中之后才恢复响应
    - redis通常是每隔1s执行一次fsync，因为fsync是IO消耗操作，这会对性能产生影响。

    



## Redis 主从节点

- 主节点不会进行持久化操作，用于服务用户
- 从节点用于备份，没有来自客户端的压力，更专注持久化。
- 当网络分区的时候，主从可能出现无法通信的情况，此时会出现主从不一致，如果主节点宕机，那么数据将会完全丢失。
- 应对这个问题，没有特别好的解决办法，只能通过部署多个从节点，以及做好网络监控工作。

### Redis混合备份

- RDB备份在重启时会导致大量数据损失
- AOF备份在重启时会导致缓慢的启动速度



