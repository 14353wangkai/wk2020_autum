## 垃圾寻找

### 可达性分析

- 从GC根可以到达的节点都不是垃圾，反之则是垃圾
- 如何可达？
  - 
- 跨代引用的问题：
  - 处于老年代的引用必须要排除，因为基本上gc都是young gc，不会去扫描老年代对象，因此如果老年代对象引用了年轻代的对象，会导致年轻代对象升级成老年代对象
- 并发可达性分析之三色标记
  - 白色：扫描完这个对象的所有相关引用，发现根不可达。
  - 灰色：尚未扫描完，但是已经有了一个根可达情况。
  - 黑色：已经扫描完该对象的所有引用，确认不是垃圾。
- 并发可达性问题：都是由于gc线程和工作线程并发运行导致的。
  - 浮动垃圾：标记为黑色对象，但是gc执行到后面的时候，该对象所有根可达引用都没了
  - 对象消失：标记为白色对象，但是gc执行到后面的时候，该对象又有了指向它的引用
    - 充要条件：插入一条或者多条从**黑色对象到白色对象的新的引**用&**删除了全部从灰色到白色对象**的直接或间接引用

- 如何解决并发可达性问题
  - 增量更新：
    - 一旦黑色对象引用白色对象的时候，就将**这个黑色对象记录下来**，当并发扫描结束之后，以黑色对象为根重新扫描。
    - 毫无疑问，以黑色对象为根重新进行扫描依然会出现对象消失，而且”黑色-》白色“的浮动垃圾现象是无法解决的
  - 原始快照：
    - 灰色对象要删除指向白色对象的引用关系时候，就要将**这个灰色对象记录下来**，以这些对象为根重新扫描。
  - 

- 无论如何并发可达性都是假的，目的在于减少stw时间

### 什么是gc根

- 具有全局性质的引用
  - 常量，类静态属性
  - 栈帧的本地变量表



### 如何减少查询次数

- 记忆集
- 卡表

