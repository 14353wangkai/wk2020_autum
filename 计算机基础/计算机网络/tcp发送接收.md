## TCP报文头：不包含IP地址

![  ](https://pic4.zhimg.com/v2-8f5725f163d7f6390a75f3a2d337bc1c_r.jpg)

- 原端口和目的端口
- 序列码
- ack确认码
- 数据偏移？
- 保留位置：保留位，以后会扩展为控制位
- 9位控制位：常用的三个(ACK, SYN, FIN) ，另外三个用于错误处理，新增三位NS, CWR, ECE
  - RST：状态机直接转为listen状态状态。表示TCP连接有差错，比如主机崩溃，此时必须释放连接
  - PSH：表示对方要求立即传送缓冲区中的其他对应包，无需等待缓冲区满
  - URG：**和右下角的urgent pointer**相关，表示这个报文有紧急数据
- ECE
  - 用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小，主要是通知对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；
- 

## tcp握手挥手

- 三次握手

  ![img](https://upload-images.jianshu.io/upload_images/2846604-91b9ed7c6b066f24.png)

  

- 四次挥手

  ![img](https://upload-images.jianshu.io/upload_images/2846604-9677c82f02e126f9.png)

- 为什么要三次握手：

  - tcp要求双方都能收发消息，因此双方都要确保有收发功能

  - 第一次：确保用户可以发信息

  - 第二次：确保服务器可以接受信息

  - 第三次：确保服务器可以发信息，用户可以接受信息

    

- 为什么要四次挥手

  - 第一次：给被动端发送fin包，主动端进入fin_wait1状态

  - 第二次：被动端发送ack，表示确认收到结束指令，进入close_wait状态，主动端收到该命令之后，进入fin_wait2状态，

  - 第三次：被动端发送fin包，进入last_ack

  - 第四次：主动端发送ack，进入time_wait，在2MSL之后，断链接。

    

- 为什么要time_wait状态

  - 主要是为了防止发送出去的 **ACK** 服务端没有收到， 被动端重发 **FIN** 再次来询问，如果主动端发完就跑路了，那么服务端重发的时候就没人理他了。
  - time_wait设置为2msl的原因：包存活的最大时间是msl，2msl是来回时间。

- 大量close_wait：在收到fin包之后，服务端read方法返回异常，没有调用close方法，导致只要读异常就会累积close_wait状态。
  
  - 可能是read异常之后，没能调用
- 大量time_wait：高并发的服务器作为主动断开的一方 



## tcp可靠性实现

- 流量校验

- 错误重传

  - 等待-重传：慢，每发一个包都要等待ack消息之后才能重新传输
  - 回退N帧：将丢包后面收到的所有包抛弃，重新传输，虽然相对等待-重传快一些，但是带宽消耗大
  - 选择重传：只重传丢包的几个，缺点是需要较为复杂的维护机制

- 流量控制

  - 滑动窗口：发送方和接收方都会维护两个窗口，一个是发送，一个是接受
    - 流量窗口的大小由发送方的数据和接收方的接受窗口

- 拥塞避免

  - 慢启动：从发送1个包开始，指数级增长，当增长到阈值的时候，开始变成线性增长，直到丢包

  - [快重传]: https://www.zhihu.com/question/21789252

    每次接受端如果收到的不是顺序到达的包，那么将会返回要求，tcp要求发送方收到对应数据包的3个ack之后，将会认为是丢包。

  - 快恢复：丢包之后，不是从0开始重传，而是从拥塞避免的阈值开始。



## 可能出现的问题

https://www.jianshu.com/p/d759788ab83f

- 包重复
  - 采用sack可以实现选择重传
  - 采用dsack可以减少包重复
  - 如果收到重复包，一般是因为网络延迟，导致快重传误判
  
- 为什么会有粘包问题
  - 因为tcp是字节流注入到socket，socket再向网卡发送数据的
  - 因此可能用户前一刻发送的是一张图片，下一刻发送的是一个视频，恰好处在同一个socket中
  - 导致无法区分，因此每个数据流的结尾可以设置一个分隔符，或者在数据包的头部设置一个报文长度。

- syn cookie的计算与验证

  - cookie计算

    - `hash(saddr, daddr, sport dport,0,0)+seq+(t1<<24) +(hash(saddr, daddr, sport, dport, t1, 1)+mssind)%(1<<24)`

  - 需要验证：验证`t1`和`mssind`，其中`t1`距离当前时间`t2`要小于2MSL(默认4分钟)，`mssind<8`

    - `t1`代表服务端发送cookie的时间，单位是分钟，保留在高8位
    - `mssind`是MSS的索引，**保留在低24位，不知道是不是博客主写错了**，待考究

  - 验证算法：

    - `t1 = (cookie-hash(saddr, daddr, sport, 0, 0) - seq)>>24`
    - `if(t2 - t1 < 4) true`
    - `mssind = ((cookie-hash(saddr,daddr,sport,dport,0,0)-seq)-hash(saddr,daddr,sport,dport,t1,1))%(1<<24)`
    - `if(mssind < 8) true`

    

- syn cookie过程

  - 用户一开始发送syn数据包的时候，服务端不会建立一个半连接表，而是通过用户发送过来的信息计算得到一个syn cookie
  - 用户第二次将请求连接的时候，需要带上这个cookie，服务端再根据用户信息计算得到这个cookie值来判断是否正确，如果正确，那么分配连接资源
  - 

- 传输数据过程中，客户端关闭，或者服务端关闭，要如何确认

  - 这是我们线上另一种比较常见的状况。即使宕机是一个小概率事件，线上几千台服务器动不动一两台挂掉也是常有的事。主机崩溃不会像关机那样会预先杀死上面的进程，而是突然性的。那么此时我们的客户端准备给服务器端发送一个请求，它由write写入内核，由TCP作为一个分节发出，随后客户阻塞于read的调用（等待接收结果）。对端TCP显然不会响应这个分节，因为主机已经挂掉，于是客户端TCP持续重传分节，试图从服务器上接收一个ACK，然而服务器始终不能应答，重传数次之后，大约4~10分钟才停止，之后返回一个ETIMEDOUT错误。

    这样尽管最后还是知道对方不可达，但是很多时候我们希望比等待4~10分钟更快的知道这个结果。可以为read设置一个超时时间，就得到了一个较好的解决方法。但是这样还是需要等待一个超时时间，事实上TCP为我们提供了更好的方法，用SO_KEEPALIVE的套接字选项——相当于心跳包，每隔一段时间给对方发送一个心跳包，当对方没有响应时会一更短的时间间隔发送，一段时间后仍然无响应的话就断开这个连接。

    

## 一个tcp连接上可以发起多少个http请求？ 

- 相关问题：从url输入到页面展现经历了什么？
  - dns - tcp连接 - 路由寻址 - 数据传输 - 断开连接

- 相关问题2：一个html页面如果又几十张图片，那么这些图片是以什么方式，什么顺序发送过来，在这个过程中会简历多少连接？
  - 现代浏览器在于服务器建立了一个tcp连接之后，是否会在一个http请求完成后断开
    - 目前用的都是Http 1.1，因此会有keep-alive属性，完成这个http请求之后，不会断开http请求使用的tcp连接
  - 一个tcp连接可以对应几个http请求？
    - 只要维持长连接，一个tcp连接就可以发送多个http请求
  - 一个tcp连接中，多个http请求可以一起发送吗？
    - 在http1.1中，单个tcp连接在同一个时刻只会处理一个请求，换句话说，两个请求是串行化的，比如请求两张图片，那就必须等到第一个图片传输完毕了，才能开始处理第二个请求
    - pipeline方法：发送端客户端可以在一个连接中发送多个请求，不需要等待任何响应，但是服务器必须按照请求收到的顺序发送响应。目前浏览器都是不开启pipelining的
      - 一些代理服务器不能正确的处理http pipelining
      - 队头阻塞：i就按力气一个tcp连接之后，假设客户端在这个连接连续向服务器发送了多个请求，按照标准，服务器应该按照收到请求的顺序返回结果，这回出现短请求等待长请求的情况
    - 在http 2中，多路传输的特性，让一个tcp连接中，可以**同时**完成多个http请求
  - 为什么有时候刷新页面不需要重新进行ssl
    - 因为会有长连接
  - 浏览器对同一个host简历tcp连接是否有数量限制？
    - 在http 1.1中，如果浏览器请求的html有数十张图片，那么会开启多个tcp连接，具体多少个和浏览器相关，比如chrome就默认支持6个连接