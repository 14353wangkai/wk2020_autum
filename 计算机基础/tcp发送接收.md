## TCP报文头

![  ](https://pic4.zhimg.com/v2-8f5725f163d7f6390a75f3a2d337bc1c_r.jpg)

- 原端口和目的端口
- 序列码
- ack确认码
- 

## tcp握手挥手

- 三次握手

  ![img](https://upload-images.jianshu.io/upload_images/2846604-91b9ed7c6b066f24.png)

  

- 四次挥手

  ![img](https://upload-images.jianshu.io/upload_images/2846604-9677c82f02e126f9.png)

- 为什么要三次握手：

  - tcp要求双方都能收发消息，因此双方都要确保有收发功能

  - 第一次：确保用户可以发信息

  - 第二次：确保服务器可以接受信息

  - 第三次：确保服务器可以发信息，用户可以接受信息

    

- 为什么要四次挥手

  - 第一次：给被动端发送fin包，主动端进入fin_wait1状态

  - 第二次：被动端发送ack，表示确认收到结束指令，进入close_wait状态，主动端收到该命令之后，进入fin_wait2状态，

  - 第三次：被动端发送fin包，进入last_ack

  - 第四次：主动端发送ack，进入time_wait，在2MSL之后，断链接。

    

- 为什么要time_wait状态

  - 主要是为了防止发送出去的 **ACK** 服务端没有收到， 被动端重发 **FIN** 再次来询问，如果主动端发完就跑路了，那么服务端重发的时候就没人理他了。
  - time_wait设置为2msl的原因：包存活的最大时间是msl，2msl是来回时间。

- 大量close_wait：在收到fin包之后，服务端read方法返回异常，没有调用close方法，导致只要读异常就会累积close_wait状态。
  
  - 可能是read异常之后，没能调用
- 大量time_wait：高并发的服务器作为主动断开的一方



- ddos攻击之syn：
- syn cookie：不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。

## tcp可靠性实现

- 流量校验

- 错误重传

  - 等待-重传：慢，每发一个包都要等待ack消息之后才能重新传输
  - 回退N帧：将丢包后面收到的所有包抛弃，重新传输，虽然相对等待-重传快一些，但是带宽消耗大
  - 选择重传：只重传丢包的几个，缺点是需要较为复杂的维护机制

- 流量控制

  - 滑动窗口：发送方和接收方都会维护两个窗口，一个是发送，一个是接受
    - 流量窗口的大小由发送方的数据和接收方的接受窗口

- 拥塞避免

  - 慢启动：从发送1个包开始，指数级增长，当增长到阈值的时候，开始变成线性增长，直到丢包

  - [快重传]: https://www.zhihu.com/question/21789252

    每次接受端如果收到的不是顺序到达的包，那么将会返回要求，tcp要求发送方收到对应数据包的3个ack之后，将会认为是丢包。

  - 快恢复：丢包之后，不是从0开始重传，而是从拥塞避免的阈值开始。



## 可能出现的问题

https://www.jianshu.com/p/d759788ab83f

- 包重复
  - 采用sack可以实现选择重传
  - 采用dsack可以减少包重复
  - 如果收到重复包，一般是因为网络延迟，导致快重传误判
- 为什么会有粘包问题
  - 因为tcp是字节流注入到socket，socket再向网卡发送数据的
  - 因此可能用户前一刻发送的是一张图片，下一刻发送的是一个视频，恰好处在同一个socket中
  - 导致无法区分，因此每个数据流的结尾可以设置一个分隔符，或者在数据包的头部设置一个报文长度。

- syn攻击如何阻挡

- 传输数据过程中，客户端关闭，或者服务端关闭，要如何确认

  - 这是我们线上另一种比较常见的状况。即使宕机是一个小概率事件，线上几千台服务器动不动一两台挂掉也是常有的事。主机崩溃不会像关机那样会预先杀死上面的进程，而是突然性的。那么此时我们的客户端准备给服务器端发送一个请求，它由write写入内核，由TCP作为一个分节发出，随后客户阻塞于read的调用（等待接收结果）。对端TCP显然不会响应这个分节，因为主机已经挂掉，于是客户端TCP持续重传分节，试图从服务器上接收一个ACK，然而服务器始终不能应答，重传数次之后，大约4~10分钟才停止，之后返回一个ETIMEDOUT错误。

    这样尽管最后还是知道对方不可达，但是很多时候我们希望比等待4~10分钟更快的知道这个结果。可以为read设置一个超时时间，就得到了一个较好的解决方法。但是这样还是需要等待一个超时时间，事实上TCP为我们提供了更好的方法，用SO_KEEPALIVE的套接字选项——相当于心跳包，每隔一段时间给对方发送一个心跳包，当对方没有响应时会一更短的时间间隔发送，一段时间后仍然无响应的话就断开这个连接。

    